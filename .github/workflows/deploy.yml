name: Deploy to Production

on:
  push:
    branches:
      - main  # Trigger on pushes to main branch
  workflow_dispatch:  # Allow manual triggering

env:
  NODE_VERSION: '18'
  REMOTE_HOST: '135.181.33.13'
  REMOTE_USER: 'uswege'
  REMOTE_PATH: '/home/uswege/ess'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run tests
      run: npm test

    - name: Validate XML message structures
      run: |
        node simulate-restructure-flow.js || echo "Simulation failed, continuing..."
        node simulate-full-flow.js || echo "Full flow simulation failed, continuing..."

  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run security audit
      run: npm audit --audit-level moderate || echo "Security audit completed with warnings"

    - name: Check for vulnerabilities
      run: |
        if npm audit --audit-level high; then
          echo "âœ… No high severity vulnerabilities found"
        else
          echo "âš ï¸ High severity vulnerabilities detected"
          npm audit --audit-level high || true
        fi

  deploy:
    needs: [test, security-scan]  # Only deploy if tests and security scan pass
    runs-on: ubuntu-latest
    environment: production  # Use production environment

    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ env.REMOTE_HOST }} >> ~/.ssh/known_hosts
        echo "âœ… SSH setup completed"

    - name: Create deployment backup
      run: |
        ssh ${{ env.REMOTE_USER }}@${{ env.REMOTE_HOST }} << 'EOF'
          cd ${{ env.REMOTE_PATH }}
          timestamp=$(date +%Y%m%d_%H%M%S)
          echo "ğŸ“¦ Creating backup: ess_backup_${timestamp}.tar.gz"
          tar -czf "../ess_backup_${timestamp}.tar.gz" .env keys/ logs/ 2>/dev/null || true
          echo "âœ… Backup created successfully"

          # Keep only last 5 backups
          cd ..
          ls -t ess_backup_*.tar.gz 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
          echo "ğŸ§¹ Cleaned up old backups"
        EOF

    - name: Deploy application code
      run: |
        echo "ğŸš€ Starting deployment to ${{ env.REMOTE_HOST }}"

        # Copy application files (excluding sensitive data and build artifacts)
        tar -czf - \
          --exclude=.git \
          --exclude=node_modules \
          --exclude=.env \
          --exclude=keys/*.pem \
          --exclude=*.log \
          --exclude=coverage \
          --exclude=.nyc_output \
          --exclude=logs \
          . | ssh ${{ env.REMOTE_USER }}@${{ env.REMOTE_HOST }} "cd ${{ env.REMOTE_PATH }} && tar -xzf -"

        echo "ğŸ“ Application code deployed"

    - name: Install and configure production environment
      run: |
        ssh ${{ env.REMOTE_USER }}@${{ env.REMOTE_HOST }} << 'EOF'
          cd ${{ env.REMOTE_PATH }}

          echo "ğŸ“¦ Installing production dependencies..."
          npm ci --production --no-audit

          echo "ğŸ›‘ Stopping existing service..."
          pm2 delete ess-app || echo "No existing service to stop"

          echo "ğŸ“ Ensuring required directories exist..."
          mkdir -p logs keys temp

          echo "ğŸ”‘ Restoring SSL certificates..."
          # Restore keys from backup if they don't exist
          if [ ! -f keys/private.pem ]; then
            latest_backup=$(ls -t ../ess_backup_*.tar.gz 2>/dev/null | head -1)
            if [ -n "$latest_backup" ]; then
              tar -xzf "$latest_backup" keys/ 2>/dev/null || echo "No keys in backup"
            fi
          fi

          echo "ğŸ“ Restoring environment configuration..."
          # Restore .env from backup if it doesn't exist
          if [ ! -f .env ]; then
            latest_backup=$(ls -t ../ess_backup_*.tar.gz 2>/dev/null | head -1)
            if [ -n "$latest_backup" ]; then
              tar -xzf "$latest_backup" .env 2>/dev/null || echo "No .env in backup"
            fi
          fi

          echo "ğŸ”’ Setting secure permissions..."
          chmod 600 keys/* 2>/dev/null || true
          chmod 600 .env 2>/dev/null || true
          chmod 755 logs/

          echo "ğŸš€ Starting service with PM2..."
          pm2 start ecosystem.config.js --env production

          echo "â³ Waiting for service to initialize..."
          sleep 10

          echo "ğŸ¥ Performing health checks..."
          for i in {1..30}; do
            echo "Health check attempt $i/30..."
            # Try multiple endpoints
            if curl -s -f http://localhost:3002/health > /dev/null 2>&1 || \
               curl -s -f http://localhost:3002/ > /dev/null 2>&1 || \
               netstat -tlnp | grep :3002 > /dev/null 2>&1; then
              echo "âœ… Service is healthy"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ Service failed health checks after 30 attempts"
              echo "ğŸ“‹ PM2 Status:"
              pm2 list || echo "PM2 list failed"
              echo "ğŸ“‹ Recent logs:"
              pm2 logs ess-app --lines 20 || echo "No logs available"
              echo "ğŸ“‹ Port check:"
              netstat -tlnp | grep :3002 || echo "Port 3002 not listening"
              exit 1
            fi
            sleep 3
          done

          echo "ğŸ“Š Service status:"
          pm2 list | grep ess-app || echo "Service not found in PM2"

          echo "ğŸ’¾ Saving PM2 configuration..."
          pm2 save

          echo "âœ… Deployment completed successfully"
        EOF

    - name: Setup Enhanced Monitoring System
      run: |
        ssh ${{ env.REMOTE_USER }}@${{ env.REMOTE_HOST }} << 'EOF'
          cd ${{ env.REMOTE_PATH }}

          echo "ğŸ”§ Setting up Enhanced Monitoring System..."

          # Create monitoring directories
          mkdir -p scripts config logs

          # Set executable permissions for scripts
          chmod +x scripts/*.sh scripts/*.js 2>/dev/null || true

          # Setup sudo permissions for IPSec management (if not already set)
          if ! sudo -l | grep -q "ipsec status"; then
            echo "ğŸ” Setting up sudo permissions for monitoring..."
            echo "uswege ALL=(ALL) NOPASSWD: /usr/sbin/ipsec status, /usr/sbin/ipsec restart, /usr/sbin/ipsec start, /usr/sbin/ipsec stop" | sudo tee /etc/sudoers.d/ess-ipsec
            echo "uswege ALL=(ALL) NOPASSWD: /bin/ping" | sudo tee -a /etc/sudoers.d/ess-ipsec
            sudo chmod 440 /etc/sudoers.d/ess-ipsec
          fi

          # Setup cron jobs for monitoring
          echo "â° Setting up monitoring cron jobs..."
          (crontab -l 2>/dev/null || true; cat << CRON
# ESS Enhanced Monitoring System
*/5 * * * * ${{ env.REMOTE_PATH }}/scripts/ipsec-monitor.sh
*/2 * * * * /usr/bin/node ${{ env.REMOTE_PATH }}/scripts/connectivity-monitor.js check
0 6 * * * /usr/bin/node ${{ env.REMOTE_PATH }}/scripts/connectivity-monitor.js status >> ${{ env.REMOTE_PATH }}/logs/daily-connectivity-report.log
0 2 * * 0 find ${{ env.REMOTE_PATH }}/logs -name "*.log" -mtime +30 -delete
CRON
          ) | crontab -

          # Start enhanced keep-alive service if not already running
          echo "ğŸš€ Starting enhanced keep-alive service..."
          pm2 delete ess-keep-alive || echo "No existing keep-alive service"
          pm2 start keep-alive-daemon.js --name ess-keep-alive --log-file logs/keep-alive.log --error-file logs/keep-alive-error.log

          # Test connectivity monitoring
          echo "ğŸ§ª Testing monitoring systems..."
          if [ -f scripts/connectivity-monitor.js ]; then
            timeout 30 node scripts/connectivity-monitor.js check || echo "Initial connectivity check completed"
          fi

          # Display monitoring status
          echo "ğŸ“Š Monitoring System Status:"
          crontab -l | grep -E "(ipsec|connectivity)" || echo "No monitoring cron jobs found"
          pm2 list | grep "ess-keep-alive" || echo "Keep-alive service not found"

          echo "âœ… Enhanced Monitoring System setup completed"
        EOF

    - name: Final deployment verification
      run: |
        echo "ğŸ” Performing final verification..."

        # Test external health endpoint
        max_attempts=10
        for i in $(seq 1 $max_attempts); do
          echo "Verification attempt $i/$max_attempts..."
          if curl -s -f http://${{ env.REMOTE_HOST }}:3002/health | grep -q "healthy" || \
             curl -s -f http://${{ env.REMOTE_HOST }}:3002/ > /dev/null 2>&1; then
            echo "âœ… Deployment verified successfully!"
            echo "ğŸŒ Service is accessible at http://${{ env.REMOTE_HOST }}:3002"
            exit 0
          fi
          sleep 5
        done

        echo "âŒ Deployment verification failed"
        exit 1

    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "âœ… Deployment completed successfully"
        else
          echo "âŒ Deployment failed"
          # Here you could add Slack/Discord notifications
        fi